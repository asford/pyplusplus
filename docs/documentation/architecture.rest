============
Architecture
============

.. contents:: Table of contents

------------
Introduction
------------

This document will describe an architecture behind `pyplusplus`_. If you just 
started with `pyplusplus`_ you don't have to read this document. 

---
C++
---

C++ is very powerful programming language. The power brings complexity. It is 
not an easy task to parse C++ source files and to create in memory representation 
of declarations tree. Lets say that I've managed to do it. It is not enough.
Declarations tree is worth nothing, if user is not able to explorer it, to run
queries against it, to find out traits of a declaration or a type.

On the earlier stage of development, I realized, that all this functionality does 
not belong to code generator and should be implemented out side of it. `pygccxml`_ 
project was born. By the way, implementing all this functionality out side of
code generator, made it to be C++ parser independent. 

`pygccxml`_ provides next services:

* definition of classes, that describe C++ declaration and types

* C++ source files parsing and caching functionality

* C++ declaration and type analizers( type traits )


`pyplusplus`_ uses those services to:

* extract declarations from source files

* find out declaration default configuration:

  * call policies for functions

  * indexing suite parameters

  * generate warnings/hints
  
  * ...

* provide powerful query interface

pyplusplus & pygccxml integration
---------------------------------

In general `pygccxml`_ provides two main services "parsing" and "declarations tree".
`pyplusplus`_ uses different approaches to exposes those services to the user.

Parsing integration
-------------------
`pyplusplus`_ provides it's own API to configure and run `pygccxml`_ parsing
services. The "API" I am talking about, is arguments to ``module_builder.__init__``
method. This method takes all arguments needed to envoke "parsing" services.
This has been done to simplify usage of `pyplusplus`_.


Declarations tree integration
-----------------------------

Declarations tree API consists from 3 parts:

* interface definition:

  * ``declaration_t`` and all classes that derive from it

  * ``type_t`` and all classes that derive from it

* type traits

* query engine API


The user should be familiar with those part and relevant API. You may ask "why"?
The answer is simple: in my opinion, wrapping/hidding/modifying the API will not 
give any value. 

The question I should answer is how this API integrated? Before I start to 
explain, lets take a look on next source code:

::

  mb = module_builder_t( ... )

::

  details = mb.namespace( 'details' )
  details.exclude()


What you see here, is an example of code, that will be\\is written in all projects
that use `pyplusplus`_:

* find declaration(s)

* apply code generator engine configuration changes

What is the main point of this example? It is perfectly good, it makes a lot of 
sence to the user to configure code generation engine using declarations tree 
hierarchy. Now, I think you understand the problem: how does `pyplusplus`_ add
missinig functionality to ``pygccxml.declarations`` classes? There were few 
possible solutions to the problem. `pyplusplus`_ implements the solution using
factory design pattern. 

1. ``pygccxml.parser`` package interface was extendent. Instead of creating
   a concrete instance of declaration class or type, ``pygccxml.parser`` package
   uses factory.
   
2. ``pyplusplus.decl_wrappers`` package defines classes, that derives from
   ``pygccxml.declarations`` classes and defines the factory.

Also, this solution is not the simplest one, it provides an additional value to
the project:

* code generation engine configuration and declarations tree are tightly coupled

* all functionality provided by ``pygccxml.declarations`` and ``pygccxml.parser``
  packages is available for ``pyplusplus.decl_wrappers`` classes

* classes defined in ``pyplusplus.decl_wrappers`` package implement next 
  functionality:
  
  * setting reasonable defaults for code generation engine( call policies, 
    indexing suite, ... )
    
  * provides user with additional information( warnings and hints )
  
* as a bonus, `pygccxml`_ remained to be stand-alone project

----------------------
Code generation engine
----------------------

Code generation for `boost.python`_ library is a difficult process. I don't know 
what about you, but when I have to solve some complex task, I prefer to use 
`divide and conquer`_ paradigm. There are 2 different problems code generation
engine should solve:

* What code should be created in order to export a declaration?

  I mean what `boost.python`_ code should be generated if you want to export this
  or that declaration.

  Code creators is the solution to this problem.
  
* How it should be written to files?

  Remember, `pyplusplus`_ is targeting big projects. It can not generate all code
  in one file - this will not work, not at all.
  
  Code creators and file writers provides solution to this problem.


.. _`divide and conquer` : http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm


Code creators
-------------

Do you know how many ways exist to export member function? It is up to you to 
find the answer to the question. Please consider next function properties and
mix of them:

* function is non virtual, virtual or pure virtual

* function is public, protected or private

* function could be static

* function could be an ``operator()`` or  an ``operator[]``

* function could be overloaded

As you see, there are a lot of use cases. How does ``code creator``s solves the 
problem? There is almost a direct mapping between ``code creator``s and use cases.
``Code creator`` knows what code should be generated, in order to export a 
declaration. That is the only job of ``code creator``s. For example:

* ``code_creators.enum_t`` generates registration code for an enumeration
  
* ``code_creators.indexing_suite2_t`` generates registration code for an stl container

* ``code_creators.mem_fun_pv_t`` generates registration code for public, pure 
  virtual function
  
* ``code_creators.mem_fun_pv_wrapper_t`` generates declaration code for public, 
  pure virtual function
  
* ``code_creators.include_t`` generates include directives

* ``code_creators.custom_text_t`` adds some custom( read user ) text\\code to 
  the generated code

As you can see, there are primary 2 kinds of ``code creator``s: declaration based 
and others. Declaration based creator generate code, that is needed to export the
declaration. There a lot of use cases, where in order to export a declaration,
`pyplusplus`_ builds more then one ``code creator``. For example: in order to 
export virtual function 3 ``code creator``s are built: 

( I will reuse example from `boost.python`_ `tutorials`__.)

.. __ : http://boost.org/libs/python/doc/tutorial/doc/html/python/exposing.html#python.virtual_functions_with_default_implementations

1. ``BaseWrap::f``

2. ``BaseWrap::default_f``

3. ``f`` registration code

Reminder: classes, defined in ``pyplusplus.decl_wrappers`` package, are used as
configuration to ``code creator``. So, ``code creator`` keeps reference to 
declaration and when it is requested to generate code, it does this according
to declaration configuration.

Now when you understand, what ``code creator`` is, it is a time to move on - composite 
code creator. Composite code creator is a creator, that contains other creators.
For example: ``code_creators.class_t`` or ``code_creators.module_t``. They embed
the code created by internal code creators within the code they create. 








.. _`pyplusplus` : ./../pyplusplus.html
.. _`pygccxml` : ./../../pygccxml/pygccxml.html
.. _`boost.python`: http://www.boost.org/libs/python/doc/index.html
.. _`Python`: http://www.python.org
.. _`GCC-XML`: http://www.gccxml.org

..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
