============
Architecture
============

.. contents:: Table of contents

------------
Introduction
------------

This document will describe an architecture behind `pyplusplus`_. 

---
C++
---

C++ is very powerful programming language. The power brings complexity. It is 
not an easy task to parse C++ source files and to create in memory representation 
of declarations tree. Lets say that I've managed to do it. It is not enough.
Declarations tree is worth nothing, if a user is not able to explorer it, to run
queries against it, to find out traits of a declaration or a type.

On the earlier stage of the development, I realized, that all this functionality 
does not belong to code generator and should be implemented out side of it. 
`pygccxml`_ project was born. `pygccxml`_ made the code generator to be smaller 
and C++ parser independent. It provides next services:

* definition of classes, that describe C++ declaration and types, and their 
  analizers ( type traits )

* C++ source files parsing and caching functionality


`pyplusplus`_ uses those services to:

* extract declarations from source files and to provide powerful query interface

* find out a declaration default configuration:

  * call policies for functions

  * indexing suite parameters

  * generate warnings/hints
  
  * ...


pyplusplus & pygccxml integration
---------------------------------

`pyplusplus`_ uses different approaches to expose these services to the user.

Parsing integration
-------------------
`pyplusplus`_ provides it's own "API" to configure and run `pygccxml`_ parsing
services. The "API" I am talking about, is arguments to ``module_builder.__init__``
method. The method takes all arguments, needed to envoke parsing services. It
has been done this way to simplify the usage of `pyplusplus`_.


Declarations tree integration
-----------------------------
Declarations tree API consists from 3 parts:

* interface definition:

  * ``declaration_t`` and all classes that derive from it

  * ``type_t`` and all classes that derive from it

* type traits

* query engine API


The user should be familiar with these part and relevant API of `pygccxml`_ project. 
The reason is simple: in my opinion, wrapping/hidding/modifying the API will not 
provide an additonal value. The interface of all those services is pretty simple 
and well polished.

The question you should ask now is: how is this API integrated? Before I start to 
explain, lets take a look on next source code:

::

  mb = module_builder_t( ... )

::

  details = mb.namespace( 'details' )
  details.exclude()

::

  my_class = mb.class_( 'my_class' )
  my_class.rename("MyClass")


What you see here, is a common pattern, that will appear in all projects, that 
use `pyplusplus`_:

* find the declaration(s)

* give the instruction(s) to the code generator engine

What is the point of this example? From the user point of view it is perfectly 
good, it makes a lot of sence to configure the code generation engine, using 
the declarations tree. Now, the desired solution is clear: we should use 
declarations tree to configure the engine. So, let me to re-formulate the 
question: how does `pyplusplus`_ add missinig functionality to 
``pygccxml.declarations`` classes? There were few possible solutions to the 
problem. The next one was implemented:

1. ``pygccxml.parser`` package interface was extendent. Instead of creating
   a concrete instance of declaration classes, ``pygccxml.parser`` package uses 
   a factory.
   
2. ``pyplusplus.decl_wrappers`` package defines classes, that derive from
   ``pygccxml.declarations`` classes and defines the factory.

Also, this solution is not the simplest one, it provides an additional value to
the project:

* the code generation engine configuration and declarations tree are tightly 
  coupled

* all functionality provided by ``pygccxml.declarations`` and ``pygccxml.parser``
  packages is available for ``pyplusplus.decl_wrappers`` classes

* classes defined in ``pyplusplus.decl_wrappers`` package implement next 
  functionality:
  
  * setting reasonable defaults for the code generation engine( call policies, 
    indexing suite, ... )
    
  * provides user with additional information( warnings and hints )
  
* as a bonus, `pygccxml`_ remained to be stand-alone project

----------------------
Code generation engine
----------------------

Code generation for `Boost.Python`_ library is a difficult process. It is very 
difficult to solve it as is. I prefer to apply `divide and conquer`_ paradigm. 
There are 2 different problems the engine should solve:

.. _`divide and conquer` : http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm

* What code should be created in order to export a declaration?

  I mean what `Boost.Python`_ code should be generated if you want to export this
  or that declaration.

  Code creators is the solution to this problem.
  
* How it should be written to files?

  Remember, `pyplusplus`_ is targeting big projects. It can not generate all code
  in one file - this will not work, not at all.

  Code creators and file writers provides solution to this problem.


Code creators
-------------

Do you know how many ways exist to export member function? It is up to you to 
find the answer to the question. Please consider next function properties and
their mix:

* function is non virtual, virtual or pure virtual

* function is public, protected or private

* function could be static

* function could be an ``operator()`` or  an ``operator[]``

* function could be overloaded

As you see, there are a lot of use cases. How does ``code creator``'s solve the 
problem? There is almost a direct mapping between ``code creator``'s and use cases.
``Code creator`` knows what code should be generated, in order to export a 
declaration. That is the only job of ``code creator``. For example:

* ``code_creators.enum_t`` generates registration code for an enumeration
  
* ``code_creators.indexing_suite2_t`` generates registration code for an stl 
  containers

* ``code_creators.mem_fun_pv_t`` generates registration code for public, pure 
  virtual function
  
* ``code_creators.mem_fun_pv_wrapper_t`` generates declaration code for public, 
  pure virtual function
  
* ``code_creators.include_t`` generates include directives

* ``code_creators.custom_text_t`` adds some custom( read user ) text\\code to 
  the generated code

As you can see, there are primary 2 kinds of ``code creator``'s: declaration 
based and others. Declaration based creator generates code, that is needed to 
export the declaration. There a lot of use cases, where in order to export a 
declaration, `pyplusplus`_ builds more then one ``code creator``. For example: 
in order to export virtual function 2 ``code creator``'s are built: 

( I will reuse example from `Boost.Python`_ `tutorials`__.)

.. __ : http://boost.org/libs/python/doc/tutorial/doc/html/python/exposing.html#python.virtual_functions_with_default_implementations

1. ``BaseWrap::f``, ``BaseWrap::default_f`` - ``code_creators.mem_fun_v_wrapper_t``

2. ``f`` registration code - ``code_creators.mem_fun_v_t``


Reminder: classes, defined in ``pyplusplus.decl_wrappers`` package, are used as
configuration to ``code creator``. So, ``code creator`` keeps reference to 
declaration and when it is requested to generate code, it does this according
to the declaration configuration.

``Code creator``'s are the only classes, that generate the code!

Composite ``code creator`` is a creator, that contains other creators. Composite 
``code creator`` embeds the code, created by internal ``code creator``'s, within 
the code it creates. For example:

* ``code_creators.class_t``:

  First of all it creates class registration code ( ``class_<...>`` ), after 
  this it appends to it code generated by internal creators. 

* ``code_creators.module_body_t``:

  Here is "cut & paste" of the relevant code from the source file:

  ::

    def _create_impl(self):
        result = []
        result.append( "BOOST_PYTHON_MODULE(%s){" % self.name )
        result.append( compound.compound_t.create_internal_code( self.creators ) )
        result.append( "}" )
        return os.linesep.join( result )


Code creators tree
~~~~~~~~~~~~~~~~~~

``code_creators.module_t`` code creator is a top level code creator. It is a 
composite ``code creator`` too. Take a look on next possible "snapshot" of the
``code creators tree``:

::

  <module_t ...>
      <license_t ...>
      <include_t ...>
      <include_t ...>
      <class_wrapper_t ...>
          <mem_fun_v_wrapper_t ...>
          <mem_fun_v_wrapper_t ...>
      <module_body_t ...>
          <enum_t ...>
          <class_t ...>
              <mem_fun_v_t ...>
              <member_variable_t ...>
          <free_function_t ...>
          <...>

I hope, now you understand the termine ``code creators tree``.

Code creators tree construction
-------------------------------

``pygccxml.declarations`` package defines declarations visitor class. 
``pyplusplus.module_creator.creator_t`` class derives from this class. Its main
job is to create ``code creators tree``. You can think about this class as a
big "switch-case" statement. This is the only class that fully "understands"
declarations and ``code creators``. It reads a declaration and then constructs
one or more ``code creator``'s and put them into the tree. 

There is one interesting thing about this class you should know: this is the only
class that "sees" all declarations. It monitors all exported functions and 
variables. Thus it knows that class ``X`` is used with ``boost::shared_ptr``,
so it will set ``class_<X>`` ``HeldType`` to be ``boost::shared_ptr`` or will 
register its usage. Another interesting example is std containers. You don't have 
to say to `pyplusplus`_ to export them, it will do it by itself. You may ask
why this detail is so interesting? Because the user does not have to specify all
set of declarations he wants to export! Because, in near future, `pyplusplus`_
will analize declarations dependency graph of exported declarations. If some 
declaration should be exported and it is not, then `pyplusplus`_ will warn the
user.



File writers
------------

``File writer``'s classes is responcible for writting `code creators tree`` into
files. Lets take a look on few lines of code from ``file_writers.single_file_t`` 
class.

::

  ...
  #write_file will write the code to file only if needed.
  #extmodule is an instance of code_creators.module_t class
  self.write_file( self.file_name, self.extmodule.create() )
  #                                ^^^^^^^^^^^^^^^^^^^^^^^

``single_file_t`` does not know any ``code creator``, except the ``module_t``!

``File writer``'s do not know and will not know all ``code creator``'s.



.. _`pyplusplus` : ./../pyplusplus.html
.. _`pygccxml` : ./../../pygccxml/pygccxml.html
.. _`Boost.Python`: http://www.boost.org/libs/python/doc/index.html
.. _`Python`: http://www.python.org
.. _`GCC-XML`: http://www.gccxml.org

..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
