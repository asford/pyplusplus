============
How to ... ?
============

.. contents:: Table of contents

----------------------------------------
How to add custom exception translation?
----------------------------------------
::

  struct my_exception{
    ...
    const std::string& error() const;
    ...
  }

First of all lets define ``translate`` function:

::

  translate_code = \
  """   
    void translate(const my_exception &exception){
        PyErr_SetString( PyExc_RuntimeError, exception.error().c_str() );
    }
  """

::

  mb.add_declaration_code( translate_code )


Now we should register it:

::

  registration_code = "boost::python::register_exception_translator<my_exception>(&translate);"
  mb.add_registration_code( registration_code )

Small usage advice.
-------------------

`pyplusplus`_ allows you to define a query that will return you all exception classes:

::

  mb = module_builder_t( ... )
  exception_classes = mb.decls( lambda decl: decl.name.endswith( 'exception' ) )

Now you can iterate on ``exception_classes``, generate and register translate 
code for every class.

That's all.

-------------------------------------------------------
How to expose function, which has hand-written wrapper?
-------------------------------------------------------
::

  struct window_t{
      ...
      void get_size( int& height, int& widht ) const;
      ...
  };

You can not expose ``get_size`` function as is - ``int`` is immutable type in 
Python. So, we need to create a wrapper to the function:
::

  boost::python::tuple get_size_wrapper( const window_t& win ){
      int height(0), width( 0 );
      win.get_size( height, widht );
      return boost::python::make_tuple( height, width );
  }

::

  class_<window_t>( ... )
      .def( "get_size", &get_size_wrapper )
      ...
  ;

Now, after you know how this problem is solved. I will show how this solution 
could be integrated with `pyplusplus`_.


::

  wrapper_code = \
  """
     static boost::python::tuple get_size( const window_t& win ){
        int height(0), width( 0 );
        win.get_size( height, widht );
        return boost::python::make_tuple( height, width );
    }
  """

::

  registration_code = 'def( "get_size", &%s::get_size )' % window.wrapper_alias

::

  mb = module_builder_t( ... )
  window = mb.class_( "window_t" )
  window.member_function( "get_size" ).exclude()
  window.add_wrapper_code( wrapper_code )
  window.registration_code( registration_code )

That's all. 

------------------------------------------------------------
Fatal error C1204:Compiler limit:internal structure overflow
------------------------------------------------------------

If you get this error, that the generated file is too big. You will have to split
it to few files. Well, not you but `pyplusplus`_ you will only have to tell that 
to it.

If you are using ``module_builder_t.write_module`` method, consider to switch
to ``module_builder_t.split_module``. 

If you are using ``split_method``, but still generated code for some specific 
class could not be compiled because of error, you can ask `pyplusplus`_ to split
class registration code to few cpp files.

For more information, please read the documentation.


------------------------------------------------------
How to automatically export template functions\\class?
------------------------------------------------------

Lets say you have next C++ function:
::

  //file point.h

::

  namespace geometry{

::

  template< class T>
  struct point_t{
      T x, y;
  };

::

  template <class T> 
  double distance( const point_t<T>& point ){
      return sqrt( point.x * point.x + point.y*point.y );
  }

::

  } //namespace geometry


You should understand, that you can not export template itself, but only its
instantiations. The solution is built using next facts:

* ``sizeof( class name )`` causes a compiler to instantiate the class

* free function invocation causes a compiler to instantiate the function

Lets say that we need to exprort the class and the function template 
instantiations for ``int`` and ``cutom_type`` types. There are few ways to do it.

Simple and straightforward
--------------------------

Open your favorite editor and create a header file with the content:

::

  #include "point.h"

::

  namespace  py_details{
      inline void instantiate(){
          using namespace geometry;
          sizeof( point_t<int> );
          sizeof( point_t<cutom_type> );
          distance( point_t<int>(0,0) );
          distance( point_t<cutom_type>(0,0) );
      }
  }

Now, you add this file to the list of files you pass as input to 
``module_builder_t.__init__`` method and excludes the ``py_details`` namespace 
declarations from being exported:

::

  mb = module_builder_t( [..., just created file ], ... )
  mb.namespace( 'py_details' ).exclude()

"Dynamic" instantiation
-----------------------

Lets say you are less lucky than I, and you have to create ``X`` instantiations 
of the class\\function. Obviously, the previous approach will not work for you.
The solution is to build your own code generator, that will generate code similar 
to the one, in the previous paragragh. 

::

  from module_builder import module_builder_t, create_text_fc

::

  def generate_instantiations_string( ... ):
      ...

::

  code = generate_instantiations_string( ... )

::

  mb = module_builder_t( [ ..., create_text_fc( code ) ], ... )
  mb.namespace( 'py_details' ).exclude()


`pyplusplus`_ allows you to extract declarations from string, that contains
valid C++ code. It creates temporal header file and compiles it. At the end of
the compilation process it will remove it. You can read mode about ``create_text_fc``
function `here`__.

.. __ : ./../../pygccxml/design.html#parser-configuration-classes



I understand that the provided solution is not perfect. I understand that something
better and simpler should be done, but a priority of this is low. There are few 
tasks, that have much higher priority. Allen Bierbaum wants to fix the situation.
He created a `wiki page`_, that discuss possible solutions. Your contribution is
welcome too!

.. _`wiki page` : https://realityforge.vrsource.org/view/PyppApi/TemplateSupport



.. _`pyplusplus` : ./../pyplusplus.html
.. _`boost.python`: http://www.boost.org/libs/python/doc/index.html
.. _`Python`: http://www.python.org
.. _`GCC-XML`: http://www.gccxml.org

..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
