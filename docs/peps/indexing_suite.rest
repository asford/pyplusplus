======================
Indexing suite support
======================

.. contents:: Table of contents

-------------------
What is useful for?
-------------------

http://boost.org/libs/python/doc/v2/indexing.html

-------------
The way to go
-------------
The generated code should work, even if it contains usage of std containers
classes. There are few ways to implement indexing suite support within `pyplusplus`_.
I will describe, how I think it should be implemented and used by user.

Generated code
--------------
All generated code will have next form:
::

  class_< container, other class parameters >(name)
        .def( concrete indexing suite class< container, proxy, derived policies >() )
  ;
  
Usage example
-------------
C++ code:
::

  #include <map>
  #include <vector>

::

  std::vector<string> get_options(){...}

::
  struct my_data{...};
  std::map< int, my_data > get_data();
  
Assumption: user wants to use ``get_options`` and ``get_data`` functions. Next 
steps will describe what `pyplusplus`_ will do in this case:

1. `pyplusplus`_ will analyze functions return type and arguments. 

2. It will understand that ``std::vector< std::string >`` and ``std::map< int, my_data >`` 
   classes should be exported too. 
   
3. It will understand that those classes should be exported using indexing suite 
   functionality provided by `boost.python`_ library or `pyplusplus`_ 
   ``code repository``.

4. It will generate a code, that will use that functionality. 

So far, so good. Sometimes, there are use cases, when user has to change default
values, for example ``NoProxy`` or ``DerivedPolicies``. What interface `pyplusplus`_ 
will provide in order to change the defaults? Well, ``std::vector< std::string >``
is the class that could be found in declarations tree, right? User can find the
class and to change the defaults on that class.
::

  mb = module_builder_t( ... )
  #the next line will not work, because the real name of std::vector< std::string >
  #is platform dependent and much longer. It is there for simplicity.
  vector_of_strings = mb.class_( "std::vector< std::string >" )
  vector_of_strings.alias = "StringVector"
  vector_of_strings.held_type = ...
  vector_of_strings.indexing_suite.no_proxy = False


Please, pay attention to the next line:
::

  vector_of_strings.indexing_suite.no_proxy = False
  
Every class, that represents instantiation of some std container will have
class variable ``indexing_suite``, that will be intitialized with relevant
indexing suite class.



.. _`pyplusplus` : ./../pyplusplus.html
.. _`boost.python`: http://www.boost.org/libs/python/doc/index.html
.. _`Python`: http://www.python.org
.. _`GCC-XML`: http://www.gccxml.org

..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
