======================
C++ containers support
======================

.. contents:: Table of contents

------------
Introduction
------------

C++ has a bunch of container classes:

    * list
    * deque
    * queue
    * priority_queue
    * vector
    * stack
    * map
    * multimap
    * hash_map
    * hash_multimap
    * set
    * hash_set
    * multiset
    * hash_multiset

It is not a trivial task to expose C++ container to Python. Boost.Python has 
a functionality that will help you to expose some of STL containers to `Python`_.
This functionality called - "indexing suite". If you want, you can read more
about indexing suite `here`__.

.. __ : http://boost.org/libs/python/doc/v2/indexing.html

Boost.Python, out of the box, supports only ``vector``, ``map`` and ``hash_map``
containers. In October 2003, Raoul Gough implemented support for the rest of 
containers. Well, actually he did much more - he implemented new framework. 
This framework provides support for almost all C++ containers and also an easy 
way to add support for custom ones. You'd better read his `post`_ to 
`boost.python`_ mailing list or `documentation`_ for the new indexing suite.


Now, I am sure you have next question: if this suite is soo good, why it is not
in the main branch? The short answer is that this suite has some problems on 
MSVC 6.0 compiler and there are few users, that still use that compiler.
The long answer is here:

* http://mail.python.org/pipermail/c++-sig/2006-June/010830.html
* http://mail.python.org/pipermail/c++-sig/2006-June/010835.html


.. _`documentation` : ./indexing_suite_v2.html
.. _`post` : http://mail.python.org/pipermail/c++-sig/2003-October/005802.html

------------------------------
pyplusplus and indexing suites
------------------------------
`pyplusplus`_ implements support for both indexing suites. More over, you can 
freely mix indexing suites. For example you can expose ``std::vector<int>`` using
`boost.python`_ built-in indexing suite and ``std::map< int, std::string>`` using
Raoul Gough's indexing suite. 

-----------------
How does it work?
-----------------

In both cases, `pyplusplus`_ provides almost "hands free" solution. `pyplusplus`_
keeps track of all exported functions and variables, and if it sees that there is
a usage of stl container, it exports the container. In both cases, `pyplusplus`_
analizes the container ``value_type`` ( or in case of mapping container 
``mapped_type`` ), in order to set reasonable defaults, when it generates the code.

-------------------
Indexing suites API
-------------------

By default, `pyplusplus`_ works with built-in indexing suite. If you want to use
next version of indexing suite, you should tell this to ``module_builder_t.__init__``
method:
::

  mb = module_builder_t( ..., indexing_suite_version=2 )

Every declarated class has ``indexing_suite`` property. If the class is an 
instantiation of stl container, this property containes reference to an instance
of ``indexing_suite1_t`` or ``indexing_suite2_t`` class. 


How does `pyplusplus`_ know that a class represents stl container instantiation? 
Well, it uses ``pygccxml.declarations.container_traits`` to find out this. 
``pygccxml.declarations.container_traits`` class, provides all functionality 
needed to identify container and to find out its ``value_type`` 
( ``mapped_type`` ).
    

Built-in indexing suite API
---------------------------

`pyplusplus`_ defines ``indexing_suite1_t`` class. This class allows configure
any detail of generated code:

* ``no_proxy`` - a boolean, if ``value_type`` is one of the next types

  * fundamental type
  
  * enumeration

  * std::string or std::wstring

  * boost::shared_ptr<?>
   
  then, ``no_proxy`` will be set to ``True``, otherwise to ``False``.

* ``derived_policies`` - a string, that will be added as is to generated code

* ``element_type`` - is a reference to container ``value_type`` or ``mapped_type``.


Next version of indexing suite API
----------------------------------

In this case there is no single place, where you can configure exported container
functionality. Please take a look on next C++ code:
::

  struct item{
      ...  
  private:
      bool operator==( const item& ) const;
      bool operator<( const item& ) const;
  };
  
  struct my_data{
      std::vector<item> items;
      std::map< std::string, item > name2item_mapping;
  };


`pyplusplus`_ declarations tree will contains ``item``, ``my_data``, 
``vector<item>`` and ``map<string,item>`` class declarations. 

If ``value_type`` does not support "equal" or "less than" functionality, sort 
and search functionality could not be exported.

`pyplusplus`_ class declaration has two properties: ``equality_comparable`` and 
``less_than_comparable``. The value of those properties is calculated on first 
invocation. If `pyplusplus`_ can find ``operator==``, that works on ``value_type``, 
then, ``equality_comparable`` property value will be set to ``True``, otherwise 
to ``False``. Same process is applied on ``less_than_comparable`` property.

In our case, `pyplusplus`_ will set both properties to ``False``, thus sort and
search functionality will not be exported.

It is the time to introduce ``indexing_suite2_t`` class:

* ``container_class`` - read only property, returns reference to container class
  declaration
  
* ``container_traits`` - read only property, returns reference to the relevant
  container traits class. Container traits classes are defined in 
  ``pygccxml.declarations`` package.
  
* ``element_type`` - is a reference to container ``value_type`` or ``mapped_type``.

* ``call_policies`` - read/write property, in near future I will add code to 
  `pyplusplus`_ that will analize container ``value_type`` and will decide about
  default call policies. Just an example: for non copy constructable classes
  ``call_policies`` should be set to ``return_internal_reference``. 
  
* ``[disable|enable]_method`` - new indexing suite, allows to configure 
  functionality exported to Python, using simple bitwise operations on predefined
  flags. `pyplusplus`_ allows you to specify what methods you want to disable
  or enable. ``indexing_suite2_t.METHODS`` containes names of all supported methods.
        

In this case, `pyplusplus`

Generated code
--------------
All generated code will have next form:
::

  class_< container, other class parameters >(name)
        .def( concrete indexing suite class< container, proxy, derived policies >() )
  ;
  
Usage example
-------------
C++ code:
::

  #include <map>
  #include <vector>

::

  std::vector<string> get_options(){...}

::

  struct my_data{...};
  std::map< int, my_data > get_data();
  
Assumption: user wants to use ``get_options`` and ``get_data`` functions. Next 
steps will describe what `pyplusplus`_ will do in this case:

1. `pyplusplus`_ will analyze functions return type and arguments. 

2. It will understand that ``std::vector< std::string >`` and ``std::map< int, my_data >`` 
   classes should be exported too. 
   
3. It will understand that those classes should be exported using indexing suite 
   functionality provided by `boost.python`_ library or `pyplusplus`_ 
   ``code repository``.

4. It will generate the code, that will use that functionality. 

So far, so good. Sometimes, there are use cases, when user has to change default
values, for example ``NoProxy`` or ``DerivedPolicies``. What interface `pyplusplus`_ 
will provide in order to change the defaults? Well, ``std::vector< std::string >``
is the class that could be found in declarations tree, right? User can find the
class and change the defaults:
::

  mb = module_builder_t( ... )
  #the next line will not work, because the real name of std::vector< std::string >
  #is platform dependent and much longer. It is there for simplicity.
  vector_of_strings = mb.class_( "std::vector< std::string >" )
  vector_of_strings.alias = "StringVector"
  vector_of_strings.held_type = ...
  vector_of_strings.indexing_suite.no_proxy = False


Please, pay attention to the next line:
::

  vector_of_strings.indexing_suite.no_proxy = False
  
Every class, that represents instantiation of some std container will have
class variable ``indexing_suite``, that will be intitialized with relevant
indexing suite class.



.. _`pyplusplus` : ./../pyplusplus.html
.. _`boost.python`: http://www.boost.org/libs/python/doc/index.html
.. _`Python`: http://www.python.org
.. _`GCC-XML`: http://www.gccxml.org

..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
