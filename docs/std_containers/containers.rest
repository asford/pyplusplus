======================
C++ containers support
======================

.. contents:: Table of contents

------------
Introduction
------------

C++ has a bunch of containers classes:

    * list
    * deque
    * queue
    * priority_queue
    * vector
    * stack
    * map
    * multimap
    * hash_map
    * hash_multimap
    * set
    * hash_set
    * multiset
    * hash_multiset

It is not a trivial task to expose C++ container to Python. Boost.Python has 
a functionality that will help you to expose some of STL containers to `Python`_.
This functionality called - "indexing suite". If you want, you can read more
about indexing suite `here`__.

.. __ : http://boost.org/libs/python/doc/v2/indexing.html

Boost.Python, out of the box, supports only ``vector``, ``map`` and ``hash_map``
containers. In October 2003, Raoul Gough implemented support for the rest of 
containers. Well, actually he did much more - he implemented new framework. 
This framework provides support for almost all C++ containers and also an easy 
way to add support for custom ones. You'd better read his `post`_ to 
`boost.python`_ mailing list or `documentation`_ for the new indexing suite.


If this suite is soo good, why it is not in the main branch? You can find the 
answer here(http://mail.python.org/pipermail/c++-sig/2006-June/010830.html) and
here(http://mail.python.org/pipermail/c++-sig/2006-June/010835.html).

.. _`documentation` : ./indexing_suite_v2.html
.. _`post` : http://mail.python.org/pipermail/c++-sig/2003-October/005802.html

------------------------------
pyplusplus and indexing suites
------------------------------
`pyplusplus`_ implements support for both indexing suites. More over, you can 
freely mix indexing suites. For example you can expose ``std::vector<int>`` using
`boost.python`_ built-in indexing suite and ``std::map< int, std::string>`` using
Raoul Gough's indexing suite. 

-----------------
How does it work?
-----------------

In both cases, `pyplusplus`_ provides almost "hands free" solution. `pyplusplus`_
keeps track of all exported functions and variables, and if it sees that there is
a usage of stl container, it exports the container. In both cases, `pyplusplus`_
analizes the container ``value_type`` ( or in case of mapping containers 
``mapped_type`` ), in order to set reasonable defaults, when it generates the code.

-----------------------
Code, show me the code!
-----------------------

By default, `pyplusplus`_ works with built-in indexing suite. If you want to use
next version of indexing suite, you should tell this to ``module_builder_t.__init__``
method:
::

  mb = module_builder_t( ..., indexing_suite_version=2 )

Every declarated class has ``indexing_suite`` property. If the class is an 
instantiation of stl container, this property containes reference to an instance
of ``indexing_suite1_t`` or ``indexing_suite2_t`` class. How does `pyplusplus`_
know that the class represents stl container instantiation? Well, it uses
``pygccxml.declarations.container_traits`` to find out this. This class, provides
all functionality needed to identify container and to find out its ``value_type``
( ``mapped_type`` ). May I give you small tip? You can use 
``pygccxml.declarations.container_traits`` class in search functionality.
    

Built-in indexing suite
-----------------------
..


Indexing suite v1
-----------------
In this case, `pyplusplus`

Generated code
--------------
All generated code will have next form:
::

  class_< container, other class parameters >(name)
        .def( concrete indexing suite class< container, proxy, derived policies >() )
  ;
  
Usage example
-------------
C++ code:
::

  #include <map>
  #include <vector>

::

  std::vector<string> get_options(){...}

::

  struct my_data{...};
  std::map< int, my_data > get_data();
  
Assumption: user wants to use ``get_options`` and ``get_data`` functions. Next 
steps will describe what `pyplusplus`_ will do in this case:

1. `pyplusplus`_ will analyze functions return type and arguments. 

2. It will understand that ``std::vector< std::string >`` and ``std::map< int, my_data >`` 
   classes should be exported too. 
   
3. It will understand that those classes should be exported using indexing suite 
   functionality provided by `boost.python`_ library or `pyplusplus`_ 
   ``code repository``.

4. It will generate the code, that will use that functionality. 

So far, so good. Sometimes, there are use cases, when user has to change default
values, for example ``NoProxy`` or ``DerivedPolicies``. What interface `pyplusplus`_ 
will provide in order to change the defaults? Well, ``std::vector< std::string >``
is the class that could be found in declarations tree, right? User can find the
class and change the defaults:
::

  mb = module_builder_t( ... )
  #the next line will not work, because the real name of std::vector< std::string >
  #is platform dependent and much longer. It is there for simplicity.
  vector_of_strings = mb.class_( "std::vector< std::string >" )
  vector_of_strings.alias = "StringVector"
  vector_of_strings.held_type = ...
  vector_of_strings.indexing_suite.no_proxy = False


Please, pay attention to the next line:
::

  vector_of_strings.indexing_suite.no_proxy = False
  
Every class, that represents instantiation of some std container will have
class variable ``indexing_suite``, that will be intitialized with relevant
indexing suite class.



.. _`pyplusplus` : ./../pyplusplus.html
.. _`boost.python`: http://www.boost.org/libs/python/doc/index.html
.. _`Python`: http://www.python.org
.. _`GCC-XML`: http://www.gccxml.org

..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
