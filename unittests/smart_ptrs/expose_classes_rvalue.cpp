// This file has been generated by Py++.

// Copyright 2004 Roman Yakovenko.
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#include "boost/python.hpp"

#include "classes.hpp"

#include "iostream"

# include <boost/python/converter/from_python.hpp>
# include <boost/python/converter/rvalue_from_python_data.hpp>
# include <boost/python/converter/registered.hpp>

namespace bp = boost::python;
namespace bpc = boost::python::converter;

namespace boost{ namespace python{

    template<class T>
    inline T * get_pointer(smart_ptr_t<T> const& p){
        return p.get();
    }

    template <class T>
    struct pointee< smart_ptr_t<T> >{
        typedef T type;
    };

} }

template <typename T>
struct smart_ptr_to_python{

    static PyObject *
    convert(smart_ptr_t<T> const& s_ptr){
        if( !s_ptr.get() ){
            return bp::detail::none();
        }
        else{
            return bpc::registered< smart_ptr_t<T> const&>::converters.to_python(&s_ptr);
        }
    }

};

template <class SmartPtrInst>
struct smart_ptr_from_python {

    typedef typename boost::python::pointee<SmartPtrInst>::type Pointee;

    smart_ptr_from_python() {
        bpc::registry::insert( &convertible, &construct, bp::type_id<SmartPtrInst>() );
    }

private:

    static void* convertible(PyObject *p) {
        // can always produce a pointer from None.
        if (p == Py_None)
            return p;
        // Otherwise, we can do it if we can get the pointee out.
        void *result = bpc::get_lvalue_from_python(p, bpc::registered<Pointee>::converters);
        return result;
    }

    static void construct(PyObject* source, bpc::rvalue_from_python_stage1_data* data){
        void* const storage = ((bpc::rvalue_from_python_storage<SmartPtrInst>*)data)->storage.bytes;
        // Deal with the "None" case.
        if (data->convertible == source)
            new (storage) SmartPtrInst();  // Or whatever you want.
        else
            new (storage)SmartPtrInst(static_cast<Pointee*>(data->convertible));
        data->convertible = storage;
    }
};


struct base_i_wrapper : base_i, bp::wrapper< base_i > {

    base_i_wrapper()
    : base_i()
      , bp::wrapper< base_i >(){
        // null constructor

    }

    virtual int get_value(  ) const {
        bp::override func_get_value = this->get_override( "get_value" );
        return func_get_value(  );
    }

};

struct derived_wrapper_t : derived_t, bp::wrapper< derived_t > {

    derived_wrapper_t(derived_t const & arg )
    : derived_t( arg )
      , bp::wrapper< derived_t >(){
        // copy constructor

    }

    derived_wrapper_t(int value )
    : derived_t( value )
      , bp::wrapper< derived_t >()
    {   // Normal constructor

    }

    virtual int get_add_value(  ) const  {
        if( bp::override func_get_add_value = this->get_override( "get_add_value" ) )
            return func_get_add_value(  );
        else
            return derived_t::get_add_value(  );
    }


    int default_get_add_value(  ) const  {
        return derived_t::get_add_value( );
    }

    virtual int get_value(  ) const  {
        if( bp::override func_get_value = this->get_override( "get_value" ) )
            return func_get_value(  );
        else
            return derived_t::get_value(  );
    }


    int default_get_value(  ) const  {
        return derived_t::get_value( );
    }

};


BOOST_PYTHON_MODULE( custom_sptr ){
    bp::class_< base_i_wrapper, boost::noncopyable >( "base_i" )
        .def( "get_value", bp::pure_virtual( &::base_i::get_value ) );

    bp::class_< derived_wrapper_t, bp::bases< base_i >, smart_ptr_t<derived_t> >( "derived_t", bp::init< int >(( bp::arg("value") ))  )
        .def( "get_add_value", &::derived_t::get_add_value, &derived_wrapper_t::default_get_add_value )
        .def( "get_value", &::derived_t::get_value, &derived_wrapper_t::default_get_value );

    bp::def( "const_ref_get_value", &::const_ref_get_value );
    bp::def( "ref_get_value", &::ref_get_value );
    bp::def( "val_get_value", &::val_get_value );

    smart_ptr_from_python< smart_ptr_t< base_i> >();
    bp::to_python_converter< smart_ptr_t<base_i>, smart_ptr_to_python< base_i > >();

    smart_ptr_from_python< smart_ptr_t< derived_t> >();
    bp::to_python_converter< smart_ptr_t<derived_t>, smart_ptr_to_python< derived_t > >();

    bp::implicitly_convertible< smart_ptr_t< derived_t >, smart_ptr_t< base_i > >();

}
