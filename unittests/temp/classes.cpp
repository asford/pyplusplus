// This file has been generated by pyplusplus.

// Copyright 2004 Roman Yakovenko.
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#include "boost/python.hpp"
#ifdef _MSC_VER
    #pragma hdrstop
#endif //_MSC_VER

#include "unittests/data/classes_to_be_exported.hpp"

namespace bp = boost::python;

struct constructor1_wrapper : classes::constructors::constructor1, bp::wrapper< classes::constructors::constructor1 > {

    constructor1_wrapper(classes::constructors::constructor1 const & arg )
    : classes::constructors::constructor1( arg )
      , bp::wrapper< classes::constructors::constructor1 >()
    {}

    constructor1_wrapper( )
    : classes::constructors::constructor1( )
      , bp::wrapper< classes::constructors::constructor1 >()
    {}

    constructor1_wrapper(int x, int y )
    : classes::constructors::constructor1( x, y )
      , bp::wrapper< classes::constructors::constructor1 >()
    {}

    constructor1_wrapper(int y, ::classes::constructors::constructor1 const & x )
    : classes::constructors::constructor1( y, x )
      , bp::wrapper< classes::constructors::constructor1 >()
    {}

    constructor1_wrapper(double const arg0 )
    : classes::constructors::constructor1( arg0 )
      , bp::wrapper< classes::constructors::constructor1 >()
    {}

    constructor1_wrapper(::classes::constructors::constructor1::internal_data const arg0 )
    : classes::constructors::constructor1( arg0 )
      , bp::wrapper< classes::constructors::constructor1 >()
    {}

};

struct abstract_wrapper : classes::abstracts::abstract, bp::wrapper< classes::abstracts::abstract > {

    abstract_wrapper( )
    : classes::abstracts::abstract( )
      , bp::wrapper< classes::abstracts::abstract >()
    {}

    abstract_wrapper(int arg0 )
    : classes::abstracts::abstract( arg0 )
      , bp::wrapper< classes::abstracts::abstract >()
    {}

    abstract_wrapper(int arg0, double arg1, ::classes::abstracts::abstract const & arg2 )
    : classes::abstracts::abstract( arg0, arg1, arg2 )
      , bp::wrapper< classes::abstracts::abstract >()
    {}

    virtual int pure_virtual( ::classes::abstracts::abstract const & arg0 ) const {
        bp::override pure_virtual = this->get_override( "pure_virtual" );
        return pure_virtual( boost::ref(arg0)  );
    }

    virtual bool overloaded_virtual(  ){
        if( bp::override overloaded_virtual = this->get_override( "overloaded_virtual" ) )
            return overloaded_virtual(  );
        else
            return classes::abstracts::abstract::overloaded_virtual(  );
    }
    
    virtual bool default_overloaded_virtual(  ){
        return this->classes::abstracts::abstract::overloaded_virtual( );
    }

    virtual bool overloaded_virtual( int arg0 ){
        if( bp::override overloaded_virtual = this->get_override( "overloaded_virtual" ) )
            return overloaded_virtual( arg0  );
        else
            return classes::abstracts::abstract::overloaded_virtual( arg0  );
    }
    
    virtual bool default_overloaded_virtual( int arg0 ){
        return this->classes::abstracts::abstract::overloaded_virtual( arg0 );
    }

    virtual int overloaded_pure_virtual( int arg0 ) const {
        bp::override overloaded_pure_virtual = this->get_override( "overloaded_pure_virtual" );
        return overloaded_pure_virtual( arg0  );
    }

    virtual void overloaded_pure_virtual( double arg0 ) const {
        bp::override overloaded_pure_virtual = this->get_override( "overloaded_pure_virtual" );
        overloaded_pure_virtual( arg0  );
    }

    virtual int some_virtual(  ){
        if( bp::override some_virtual = this->get_override( "some_virtual" ) )
            return some_virtual(  );
        else
            return classes::abstracts::abstract::some_virtual(  );
    }
    
    virtual int default_some_virtual(  ){
        return this->classes::abstracts::abstract::some_virtual( );
    }

};

struct protected_static_t_wrapper : classes::protected_static::protected_static_t, bp::wrapper< classes::protected_static::protected_static_t > {

    protected_static_t_wrapper(classes::protected_static::protected_static_t const & arg )
    : classes::protected_static::protected_static_t( arg )
      , bp::wrapper< classes::protected_static::protected_static_t >()
    {}

    protected_static_t_wrapper()
    : classes::protected_static::protected_static_t()
      , bp::wrapper< classes::protected_static::protected_static_t >()
    {}

    static int identity( int x ){
        return ::classes::protected_static::protected_static_t::identity( x  );
    }

    virtual int invert_sign( int x ){
        return this->classes::protected_static::protected_static_t::invert_sign( x );
    }

};

BOOST_PYTHON_MODULE(classes){
    bp::class_< classes::fundamentals::fundamental2 >( "FUNDAMENTAL2" );

    bp::class_< classes::hierarchical::fruit >( "fruit" );

    bp::class_< classes::hierarchical::apple, bp::bases< classes::hierarchical::fruit > >( "apple" );

    if( true ){
        typedef bp::class_< constructor1_wrapper > constructor1_exposer_t;
        constructor1_exposer_t constructor1_exposer = constructor1_exposer_t( "constructor1" );
        bp::scope constructor1_scope( constructor1_exposer );
        bp::class_< classes::constructors::constructor1::internal_data >( "internal_data" );
        constructor1_exposer.def( bp::init< >()[bp::default_call_policies()] );
        constructor1_exposer.def( bp::init< int, int >(( bp::arg("x"), bp::arg("y") ))[bp::default_call_policies()] );
        constructor1_exposer.def( bp::init< int, classes::constructors::constructor1 const & >(( bp::arg("y"), bp::arg("x") )) );
        constructor1_exposer.def( bp::init< double >(( bp::arg("arg0") ))[bp::default_call_policies()] );
        constructor1_exposer.def( bp::init< classes::constructors::constructor1::internal_data >(( bp::arg("arg0") ))[bp::default_call_policies()] );
    }

    bp::implicitly_convertible< double const, classes::constructors::constructor1 >();

    bp::implicitly_convertible< classes::constructors::constructor1::internal_data const, classes::constructors::constructor1 >();

    bp::class_< abstract_wrapper, boost::noncopyable >( "abstract" )    
        .def( bp::init< >()[bp::default_call_policies()] )    
        .def( bp::init< int >(( bp::arg("arg0") ))[bp::default_call_policies()] )    
        .def( bp::init< int, double, classes::abstracts::abstract const & >(( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") )) )    
        .def( "pure_virtual"
                , bp::pure_virtual( &::classes::abstracts::abstract::pure_virtual )
                , ( bp::arg("arg0") )
                , bp::default_call_policies() )    
        .def( "overloaded_virtual"
                , (bool ( ::classes::abstracts::abstract::* )(  ) )(&classes::abstracts::abstract::overloaded_virtual), (bool ( abstract_wrapper::* )(  ) )(&abstract_wrapper::default_overloaded_virtual)
                , bp::default_call_policies() )    
        .def( "overloaded_virtual"
                , (bool ( ::classes::abstracts::abstract::* )( int ) )(&classes::abstracts::abstract::overloaded_virtual), (bool ( abstract_wrapper::* )( int ) )(&abstract_wrapper::default_overloaded_virtual)
                , ( bp::arg("arg0") )
                , bp::default_call_policies() )    
        .def( "overloaded_pure_virtual"
                , bp::pure_virtual( (int ( ::classes::abstracts::abstract::* )( int ) const)(&::classes::abstracts::abstract::overloaded_pure_virtual) )
                , ( bp::arg("arg0") )
                , bp::default_call_policies() )    
        .def( "overloaded_pure_virtual"
                , bp::pure_virtual( (void ( ::classes::abstracts::abstract::* )( double ) const)(&::classes::abstracts::abstract::overloaded_pure_virtual) )
                , ( bp::arg("arg0") )
                , bp::default_call_policies() )    
        .def( "some_virtual"
                , &classes::abstracts::abstract::some_virtual, &abstract_wrapper::default_some_virtual
                , bp::default_call_policies() );

    bp::class_< protected_static_t_wrapper >( "protected_static_t" )    
        .def( "identity"
                , (int (*)( int ))(&protected_static_t_wrapper::identity)
                , ( bp::arg("x") )
                , bp::default_call_policies() )    
        .def( "invert_sign"
                , &protected_static_t_wrapper::invert_sign
                , ( bp::arg("x") )
                , bp::default_call_policies() )    
        .staticmethod( "identity" );

    bp::class_< classes::fundamentals::fundamental1 >( "fundamental1" );

    if( true ){
        typedef bp::class_< classes::scope_based::scope_based_exposer > scope_based_exposer_exposer_t;
        scope_based_exposer_exposer_t scope_based_exposer_exposer = scope_based_exposer_exposer_t( "scope_based_exposer" );
        bp::scope scope_based_exposer_scope( scope_based_exposer_exposer );
        bp::enum_<classes::scope_based::scope_based_exposer::EColor>("EColor")
            .value("blue", classes::scope_based::scope_based_exposer::blue)
            .value("green", classes::scope_based::scope_based_exposer::green)
            .value("red", classes::scope_based::scope_based_exposer::red)
            .export_values()
            ;
        scope_based_exposer_exposer.def( bp::init< >()[bp::default_call_policies()] );
    }

    bp::class_< classes::noncopyables::noncopyable1, boost::noncopyable >( "noncopyable1" )    
        .def( bp::init< >()[bp::default_call_policies()] );
}
