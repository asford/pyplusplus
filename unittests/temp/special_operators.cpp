// This file has been generated by pyplusplus.

// Copyright 2004 Roman Yakovenko.
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#include "boost/python.hpp"
#ifdef _MSC_VER
    #pragma hdrstop
#endif //_MSC_VER

#include "unittests/data/special_operators_to_be_exported.hpp"

namespace bp = boost::python;

struct base_call_t_wrapper : special_operators::base_call_t, bp::wrapper< special_operators::base_call_t > {

    base_call_t_wrapper()
    : special_operators::base_call_t()
      , bp::wrapper< special_operators::base_call_t >()
    {}

    virtual int operator()( int x, int y ) const {
        bp::override call = this->get_override( "__call__" );
        return call( x, y  );
    }

};

struct derive_call_t_wrapper : special_operators::derive_call_t, bp::wrapper< special_operators::derive_call_t > {

    derive_call_t_wrapper(special_operators::derive_call_t const & arg )
    : special_operators::derive_call_t( arg )
      , bp::wrapper< special_operators::derive_call_t >()
    {}

    derive_call_t_wrapper()
    : special_operators::derive_call_t()
      , bp::wrapper< special_operators::derive_call_t >()
    {}

    virtual int operator()( int x, int y ) const {
        if( bp::override call = this->get_override( "__call__" ) )
            return call( x, y  );
        else
            return special_operators::derive_call_t::operator()( x, y  );
    }
    
    virtual int default_call( int x, int y ) const {
        return this->special_operators::derive_call_t::operator()( x, y );
    }

};

struct call_t_wrapper : special_operators::call_t, bp::wrapper< special_operators::call_t > {

    call_t_wrapper(special_operators::call_t const & arg )
    : special_operators::call_t( arg )
      , bp::wrapper< special_operators::call_t >()
    {}

    call_t_wrapper()
    : special_operators::call_t()
      , bp::wrapper< special_operators::call_t >()
    {}

    virtual bool operator()( bool x ){
        if( bp::override call = this->get_override( "__call__" ) )
            return call( x  );
        else
            return special_operators::call_t::operator()( x  );
    }
    
    virtual bool default_call( bool x ){
        return this->special_operators::call_t::operator()( x );
    }

};

BOOST_PYTHON_MODULE(special_operators){
    bp::class_< special_operators::to_wstring_t >( "to_wstring_t" )    
        .def( "__str__", &special_operators::to_wstring_t::operator ::std::wstring ,bp::default_call_policies() );

    bp::implicitly_convertible< special_operators::to_wstring_t, std::wstring >();

    bp::class_< special_operators::operators_t >( "operators_t" )    
        .def( "__int__", &special_operators::operators_t::operator int ,bp::default_call_policies() )    
        .def( "__float__", &special_operators::operators_t::operator double ,bp::default_call_policies() )    
        .def( "__str__", &special_operators::operators_t::operator char const * ,bp::default_call_policies() )    
        .def( "__call__"
                , &special_operators::operators_t::operator()
                , bp::default_call_policies() );

    bp::implicitly_convertible< special_operators::operators_t, int >();

    bp::implicitly_convertible< special_operators::operators_t, double >();

    bp::implicitly_convertible< special_operators::operators_t, char const * >();

    bp::class_< special_operators::to_string_t >( "to_string_t" )    
        .def( "__str__", &special_operators::to_string_t::operator ::std::string ,bp::default_call_policies() );

    bp::implicitly_convertible< special_operators::to_string_t, std::string >();

    bp::class_< base_call_t_wrapper, boost::noncopyable >( "base_call_t" )    
        .def( "__call__"
                , bp::pure_virtual( &::special_operators::base_call_t::operator() )
                , ( bp::arg("x"), bp::arg("y") )
                , bp::default_call_policies() );

    bp::class_< derive_call_t_wrapper, bp::bases< special_operators::base_call_t > >( "derive_call_t" )    
        .def( "__call__"
                , &special_operators::derive_call_t::operator(), &derive_call_t_wrapper::default_call
                , ( bp::arg("x"), bp::arg("y") )
                , bp::default_call_policies() );

    bp::class_< call_t_wrapper >( "call_t" )    
        .def( "__call__"
                , (int ( ::special_operators::call_t::* )( int,int ) )(&special_operators::call_t::operator())
                , ( bp::arg("x"), bp::arg("y") )
                , bp::default_call_policies() )    
        .def( "__call__"
                , (double ( ::special_operators::call_t::* )( double ) )(&special_operators::call_t::operator())
                , ( bp::arg("x") )
                , bp::default_call_policies() )    
        .def( "__call__"
                , (bool ( ::special_operators::call_t::* )( bool ) )(&special_operators::call_t::operator()), (bool ( call_t_wrapper::* )( bool ) )(&call_t_wrapper::default_call)
                , ( bp::arg("x") )
                , bp::default_call_policies() );

    bp::def( "virtual_call"
            , &special_operators::virtual_call
            , ( bp::arg("x"), bp::arg("arg1"), bp::arg("arg2") )
            , bp::default_call_policies() );
}
